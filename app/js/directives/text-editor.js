/* angular-meditor directive
 */

angular.module('angular-meditor', [])
  .directive('meditor', ['$timeout', function ($timeout,$document, CKolorFactory, $window) {
    'use strict';

    return {
      scope: {
        ngModel: '=',
        overlay: '=',
        maxtimer:'@',
        blur: '&onBlur',
        delete: '&onDelete',
        zoomRatio: '@',
        playground: '@?',
        toolbarContainer: '@?',
        
      },
      require: '?ngModel',
      transclude: true,
      templateUrl: 'templates/directives/editor.html',
      
      link: function (scope, element, attributes, ctrl) {
        // console.log(scope);
        var date=new Date();
        date.setMinutes(0);
        date.setSeconds(0);
        
        scope.model = {
          ngModel: scope.ngModel,
          showToolbar: false,
          isDragging: false,
          isResizing: false,
          isRotating: false,
          clickCount: 0,
          showColors: false,

        };
        scope.contenteditable= 'false';
        scope.maxTimerStopWatchString = "59:59";
  
        scope.$watch('model.ngModel', function () {
          $timeout(function () {
            scope.ngModel = scope.model.ngModel;
            scope.overlay.o_height = $content.height();
          });
        });
        
        scope.$watch('model.showToolbar', function(newVal, oldVal) {
          if (newVal == false)
          {
            scope.blur({overlay: scope.overlay});
            $content[0].blur();
          }
        });

        scope.editabled = function(e) {
          // console.log('Anny');
          scope.contenteditable = 'true';
        }

        scope.movable = function(e) {
          // scope.contenteditable = 'false';
        }

        scope.$watch('maxtimer', function(newVal, oldVal) {
          // console.log("maxtimer: ", newVal, oldVal);
          if (!newVal) {
            scope.maxTimerStopWatchString = "59:59";
            // console.log(element, "maxtimer undefined or null");
          } else {
            scope.maxTimerStopWatchString = convertSecondsToStopWatchString(newVal);
          }
        })

        scope.$watch('overlay.o_width', function() {
          $timeout(function(){
            scope.overlay.o_height = $content.height();
          });
        });
        // console.log(scope.overlay);

        // toolbar position
        scope.position = {
          top: 10,
          left: 10,
          below: false,
          mouseTop: 10,
          mouseLeft: 10,
        };
        scope.textMode = 0;
        scope.selectedColor = "black";
        scope.textAlignment = "center";
        // fontSize options
        scope.sizeOptions = [
          {
            label: '9',
            value: 9
          },
          {
            label: '10',
            value: 10
          },
          {
            label: '11',
            value: 11
          },
          {
            label: '12',
            value: 12
          },
          {
            label: '13',
            value: 13
          },
          {
            label: '14',
            value: 14
          },
          {
            label: '16',
            value: 16
          },
          {
            label: '18',
            value: 18
          },
          {
            label: '20',
            value: 20
          },
          {
            label: '24',
            value: 24
          },
          {
            label: '32',
            value: 32
          },
          {
            label: '36',
            value: 36
          },
          {
            label: '48',
            value: 48
          },
          {
            label: '64',
            value: 64
          },
          {
            label: '72',
            value: 72
          },
          {
            label: '144',
            value: 144
          },
          {
            label: '288',
            value: 288
          }
        ];
        scope.size = scope.sizeOptions[11].value;

        scope.familyOptions = [
          'Chalkduster',
          'Futura',
          'Helvetica',
          // 'Hanzipen SC',
          'Nadeem',
          'Palatino',
          'Seravek'
        ];


        scope.family = scope.familyOptions[2];

        scope.colorSwatch = ['#4587D4', '#F5A623', '#F8E71C', '#8B572A',
          '#50E3C2', '#B8E986', '#000000', '#4A4A4A',
          '#7ED321', '#417505', '#BD10E0', '#7B2DBE',
          '#9B9B9B', '#FFFFFF', '#2FB698', '#D0021B'

        ]

        // current styles of selected elements
        // used to highlight active buttons
        scope.styles = {};

        // tags generated by the editor
        // used to highlight active styles
        var generatedTags = {
          'b': '',
          'strong': '',
          'i': '',
          'em': '',
          'u': '',
          'font': ''
        };

        // Remy Sharp's debounce
        // https://remysharp.com/2010/07/21/throttling-function-calls
        var debounce = function (fn, delay) {
          var timer = null;
          return function () {
            var context = this, args = arguments;
            clearTimeout(timer);
            timer = setTimeout(function () {
              fn.apply(context, args);
            }, delay);
          };
        };

        var $toolbar = angular.element(element[0].querySelector('.angular-meditor-toolbar'));
        var $content = angular.element(element[0].querySelector('.angular-meditor-content'));
        var $content_wrapper = angular.element(element[0].querySelector('.angular-meditor'));
          var $selects = angular.element(element[0].querySelector('.meditor-family-selector'));
          // console.log($selects);
          var $body = angular.element(document.querySelector(scope.toolbarContainer) || document.body);
        var $playground = angular.element(document.querySelector(scope.playground) || document.body);

        // position the toolbar above or below the selected text
        var setToolbarPosition = function () {
          var toolbarHeight = $toolbar[0].offsetHeight;
          var toolbarWidth = $toolbar[0].offsetWidth;
          var spacing = 25;
          var selection = window.getSelection();

          // var range = selection.getRangeAt(0);
          var boundary = $content[0].getBoundingClientRect();

          var topPosition = boundary.top;
          var leftPosition = boundary.left;

          // if there isn't enough space at the top, place it at the bottom
          // of the selection
          if (boundary.top < (toolbarHeight + spacing)) {
            scope.position.top = topPosition + boundary.height + spacing;
            // tell me if it's above or below the selection
            // used in the template to place the triangle above or below
            scope.position.below = true;
          } else {
            scope.position.top = topPosition - toolbarHeight - spacing;
            scope.position.below = false;
          }

          // center toolbar above selected text
          scope.position.left = leftPosition - (toolbarWidth / 2) + (boundary.width / 2);

          // cross-browser window scroll positions
          var scrollLeft = (window.pageXOffset !== undefined) ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
          var scrollTop = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;

          // add the scroll positions
          // because getBoundingClientRect gives us the position
          // relative to the viewport, not to the page

          // need to consider playground left and top.
          var playground_boundary = $playground[0].getBoundingClientRect();
          // scope.position.top += scrollTop - Math.max(playground_boundary.top, 0);
          // scope.position.left += scrollLeft - Math.max(playground_boundary.left, 0);

          scope.position.top -= playground_boundary.top;
          scope.position.left -= playground_boundary.left;

            return this;
          };

          // get current selection and act on toolbar depending on it
          var checkSelection = function (e) {

            // if you click something from the toolbar
            // don't do anything
            if (e && e.target && $toolbar.find(e.target).length) {
              return false;
            }

            var newSelection = window.getSelection();

            // get selection node
            var anchorNode = newSelection.anchorNode;

            if (anchorNode == null)
              return;
            // check if selection is in the current editor/directive container
            var parentNode = anchorNode.parentNode;
            while (parentNode.tagName !== undefined && parentNode !== element[0]) {
              parentNode = parentNode.parentNode;
            }

            // if the selection is in the current editor
            if (parentNode === element[0]) {
              // check selection styles and active buttons based on it

              checkActiveButtons(newSelection);
            }

            return this;
          };

          // check current selection styles and activate buttons
          var checkActiveButtons = function (selection) {


            var parentNode = selection.anchorNode;

            if (!parentNode.tagName) {
              parentNode = selection.anchorNode.parentNode;
            }

            var childNode = parentNode.childNodes[0];


            if (childNode && childNode.tagName && childNode.tagName.toLowerCase() in generatedTags) {
              parentNode = parentNode.childNodes[0];
            }

            $timeout(function () {
              // get real styles of selected element
              scope.styles = window.getComputedStyle(parentNode, null);
              scope.selectedColor = scope.styles.color
              if (scope.styles.fontSize !== scope.size.label + 'px') {
                // set font size selector
                angular.forEach(scope.sizeOptions, function (size, i) {
                  if (scope.styles.fontSize === (size.label + 'px')) {
                    scope.size = scope.sizeOptions[i].value;
                    return false;
                  }
                });
              }

            });

          };

      scope.startStretch = function (direction, event) {
        $(event.target).addClass('on');
        scope.model.isResizing = true;
        scope.model.stretchDirection = direction;
        
        var width = $content.width();
        var height = $content.height();

        scope.position.initialWidth = width;
        scope.position.initialHeight = height;
        scope.position.initialLeft = event.screenX;
        var radians = Math.atan2(height, width);
        if (radians < 0)
        {
            radians += (2 * Math.PI);
        }
        var alpha = radians * 180 / Math.PI;
        var l = Math.sqrt(width * width + height * height) / 2;

        scope.overlay.x1 = width / 2 - l * Math.cos(radians - scope.overlay.o_degree * Math.PI / 180);
        scope.overlay.y1 = height / 2 - l * Math.sin(radians - scope.overlay.o_degree * Math.PI / 180);

        scope.overlay.initialTop = scope.overlay.o_top;
        scope.overlay.initialLeft = scope.overlay.o_left;
        event.preventDefault();
      };

      scope.startRotate = function(event) {
        $(event.target).addClass('on');
        scope.model.isRotating = true;
        event.preventDefault();
      }

      var setToolbarStatus = function (e) {
        // if you click something from the toolbar
        // don't do anything
        checkSelection(e);
        // console.log(e.keyCode);
        if (e && e.target && !($(".color-panel").find(e.target).length)) {
          scope.model.showColors = false;
        }

        if (e && e.target && $toolbar.find(e.target).length) {
          return true;
        }

        if (e && e.target && element.find(e.target).length) {
        //  console.log(e);
          $timeout(function () {
            scope.model.showToolbar = true;
            scope.model.clickCount += 1;
            scope.position.mouseTop = e.screenY;
            scope.position.mouseLeft = e.screenX;
            scope.model.isDragging = true;
            setToolbarPosition();
          });
        }
        else {
          $timeout(function () {
            scope.model.showToolbar = false;
            scope.model.showColors = false;
            scope.model.clickCount = 0;
            scope.contenteditable = false;
            
          });
        }
        // scope.contenteditable = 'false';
        return this;
      };

      var setBounds = function(el, x, y, w, h) {
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.style.width = w + 'px';
      };

      var getRotationDegree = function(el) {
        var st = window.getComputedStyle(el, null);
        var tr = st.getPropertyValue("-webkit-transform") ||
                 st.getPropertyValue("-moz-transform") ||
                 st.getPropertyValue("-ms-transform") ||
                 st.getPropertyValue("-o-transform") ||
                 st.getPropertyValue("transform") ||
                 "fail...";
        var angle = 0;
        if( tr !== "none") {
          console.log('Matrix: ' + tr);

          var values = tr.split('(')[1];

          values = values.split(')')[0];
          values = values.split(',');
          var a = values[0];
          var b = values[1];
          var c = values[2];
          var d = values[3];

          var scale = Math.sqrt(a*a + b*b);

          // arc sin, convert from radians to degrees, round
          var sin = b/scale;
          var angle = Math.round(Math.asin(sin) * (180/Math.PI));
          var radians = Math.atan2(b,a);
          if (radians < 0) {
            radians += (2 * Math.PI);
          }
          angle = Math.round( radians * (180 / Math.PI));

        }

        return angle;
      };

      // var degree = 0;      

      var mouseMove = function (e) {
          checkSelection(e);

        if (scope.model.isResizing)
        {
          if (Math.abs(scope.overlay.o_degree) == 90)
            return;
          var dw = Math.floor((e.screenX - scope.position.initialLeft) / Math.cos(scope.overlay.o_degree * Math.PI / 180));
          var w = scope.position.initialWidth;
          var h = $content.height();

          switch(scope.model.stretchDirection)
          {
            case 0: // Left
              if (dw > w - 10)
              {
                dw = w - 10;
              }
              var l = (Math.sqrt( (w - dw) * (w - dw) + h * h )) / 2;

              var width = Math.max(w - dw, 10);
              scope.overlay.o_width = width;
              $content_wrapper[0].style.width = $content[0].style.width = width + 'px';
              // setBounds($content_wrapper[0], boundary.left, boundary.top, width);
              // setBounds($content[0], boundary.left, boundary.top, width);

              // scope.position.top += dy;
              // scope.position.left += dx;
              var radians = Math.atan2(h, w - dw);
              // if (radians < 0)
              // {
              //     radians += (2 * Math.PI);
              // }
              // var alpha = radians * 180 / Math.PI;

              var x2 = (w - dw)/2 - l * Math.cos(radians - scope.overlay.o_degree * Math.PI / 180);
              var y2 = h / 2 - l * Math.sin(radians - scope.overlay.o_degree * Math.PI / 180);

              scope.overlay.o_top = scope.overlay.initialTop - y2 + scope.overlay.y1 - dw * Math.sin(scope.overlay.o_degree * Math.PI / 180);
              scope.overlay.o_left = scope.overlay.initialLeft - x2 + scope.overlay.x1 + dw * Math.cos(scope.overlay.o_degree * Math.PI / 180);
              
              break;
            case 1: // Right
              if (dw < 10 - w)
              {
                dw = 10 - w;
              }
              
              var l = (Math.sqrt( (w + dw) * (w + dw) + h * h )) / 2;

              var width = Math.max(w + dw, 10);
              scope.overlay.o_width = width;
              $content_wrapper[0].style.width = $content[0].style.width = width + 'px';
              // setBounds($content_wrapper[0], boundary.left, boundary.top, width);
              // setBounds($content[0], boundary.left, boundary.top, width);

              // scope.position.top += dy;
              // scope.position.left += dx;
              var radians = Math.atan2(h, w + dw);
              // if (radians < 0)
              // {
              //     radians += (2 * Math.PI);
              // }
              // var alpha = radians * 180 / Math.PI;

              var x2 = (w + dw)/2 - l * Math.cos(radians - scope.overlay.o_degree * Math.PI / 180);
              var y2 = h / 2 - l * Math.sin(radians - scope.overlay.o_degree * Math.PI / 180);

              scope.overlay.o_top = scope.overlay.initialTop - y2 + scope.overlay.y1;
              scope.overlay.o_left = scope.overlay.initialLeft - x2 + scope.overlay.x1;
              break;
          }
          setToolbarPosition();
          scope.model.clickCount = 0;
          return;
        }
        else if (scope.model.isRotating)
        {
          /* var rotate_X;
          var rotate_Y;
          var invert = false;
          
          if (invert) {
            rotate_X = e.pageX;
            rotate_Y = e.pageY;
          } else if (!invert) {
            rotate_X = e.pageX;
            rotate_Y = -e.pageY;
          }
          
          console.log(rotate_X, 'Rotate X');
          console.log(rotate_Y, 'Rotate Y');
          var radians = Math.atan2(rotate_X, rotate_Y);
          console.log(radians, 'Radians');
          scope.overlay.o_degree = (radians * (180/Math.PI));
          console.log(scope.overlay.o_degree, 'Degree');
         
          setToolbarPosition();
          scope.model.clickCount = 0;
          return; */ 

          var boundary = $content[0].getBoundingClientRect();
          var playground_boundary = $playground[0].getBoundingClientRect();
          var center_x = (boundary.left - playground_boundary.left)  + (boundary.width / 2);
          var center_y = (boundary.top - playground_boundary.top) + (boundary.height / 2);
          // var mouse_x = (e.clientX - playground_boundary.left) * scope.zoomRatio / 100;
          // var mouse_y = (e.clientY - playground_boundary.top) * scope.zoomRatio / 100;

          var mouse_x = e.clientX * 100 / scope.zoomRatio - playground_boundary.left;
          var mouse_y = e.clientY * 100 / scope.zoomRatio - playground_boundary.top;
          
          // console.log("boundary: ", boundary.left, ", ", boundary.top, ", ", boundary.width, ", ", boundary.height);
          // console.log("playground_boundary: ", playground_boundary.left, ", ", playground_boundary.top);
          // console.log("center: ", center_x, ", ", center_y);

          var radians = Math.atan2(mouse_x - center_x, mouse_y - center_y);
          scope.overlay.o_degree = (radians * (180 / Math.PI));
          
          // scope.overlay.newLeft = -(center_x*Math.cos(scope.overlay.o_degree)+center_y*Math.sin(scope.overlay.o_degree));
          // scope.overlay.newTop = -center_x*Math.sin(scope.overlay.o_degree)+center_y*Math.cos(scope.overlay.o_degree);
          // console.log(scope.overlay.newLeft, scope.overlay.newTop);
          // element.css('-moz-transform', 'rotate(' + degree + 'deg)');
          // element.css('-webkit-transform', 'rotate(' + degree + 'deg)');
          // element.css('-o-transform', 'rotate(' + degree + 'deg)');
          // element.css('-ms-transform', 'rotate(' + degree + 'deg)');
          setToolbarPosition();
          scope.model.clickCount = 0;
          return;
        }

          if (!scope.model.isDragging)
            return;

          if (scope.model.clickCount == 1) { // only move on first click
            var deltax = e.screenX - scope.position.mouseLeft;
            var deltay = e.screenY - scope.position.mouseTop;
            scope.position.mouseLeft = e.screenX;
            scope.position.mouseTop = e.screenY;

          scope.overlay.o_left += deltax;
          scope.overlay.o_top += deltay;

            scope.position.left += deltax;
            scope.position.top += deltay;
          }

        }
        scope.needsRefresh = false;

        var mouseUp = function (e) {
          checkSelection(e);
        scope.model.isRotating = false;
        scope.model.isResizing = false;
          scope.model.isDragging = false;

        $(".handle").removeClass('on');
        $(".rotate").removeClass('on');
        }

        // if mouse down on text overlay, show the toolbar. 
      $body.on('mousedown', setToolbarStatus);
      $playground.on('mousemove', mouseMove);
      $playground.on('mouseup', mouseUp);
        // check selection when selecting with the shift key
        $content.bind('keyup', checkSelection);
        // check the selection on every mouseup
        // it also triggeres when releasing outside the browser
        // use debounce to fix issue with Chrome
        // getting the right selection only after a delay
        // if selecting text, then single-clicking the selected text
        // document.addEventListener('mouseup', debounce(checkSelection, 200));
        $content.bind('mouseup', checkSelection);
        $content.bind('blur', debounce(checkSelection, 200));

        // if after a selection in the select,
        // the contenteditable doesn't get the focus
        // the toolbar will not hide on blur.
        // so I have to add a blur event to the selects.
        $selects.bind('blur', debounce(checkSelection, 200));
        scope.selectionData = null;
        scope.ShowColors = function (action) {
          scope.needsRefresh = true;
          scope.selectionData = scope.SaveSelection();
          scope.model.showColors = !scope.model.showColors;
          scope.colorPicker.visible = false;
        }

        scope.setAlignment = function (al) {
          scope.textAlignment = al;
          model.showColors = false;
        }

        scope.SaveSelection = function saveSelection() {
          if (window.getSelection) {
            var sel = window.getSelection();
            if (sel.getRangeAt && sel.rangeCount) {
              return sel.getRangeAt(0);
            }
          } else if (document.selection && document.selection.createRange) {
            return document.selection.createRange();
          }
          return null;
        }
        scope.RestoreSelection = function restoreSelection(range) {
          if (range) {
            if (window.getSelection) {
              var sel = window.getSelection();
              sel.removeAllRanges();
              sel.addRange(range);
            } else if (document.selection && range.select) {
              range.select();
            }
          }
        }

        // simple edit action - bold, italic, underline
        scope.SimpleAction = function (action, arg) {
          document.execCommand('styleWithCSS', false, false);
          //execOnElement($content[0],action,arg)
          if (scope.needsRefresh) {
            scope.RestoreSelection(scope.selectionData);
            scope.needsRefresh = false;
            if (arg != "transparent")
            {
              scope.colorPicker.tempColors = scope.colorPicker.tempColors.filter(function(x) { return x != arg;});
              scope.colorPicker.tempColors.unshift(arg);
              scope.colorPicker.tempColors =  scope.colorPicker.tempColors.slice(0,4);  
            }
          }
          // arg = arg || null;
          document.execCommand(action, false, arg);
          if (action == 'foreColor') {
            scope.selectedColor = arg;
          }
          // custom event for two-way binding
          scope.$broadcast('meditor-change');
          scope.model.showColors = false;
        };

        scope.colorPicker = {
          visible: false,
          color : "#a10005",
           lastColor : "#FF0000",
           tempColors : ["#FF0000","#00FF00","#0000FF","#F0F0F0"],
          onColor : function(colors) {
            console.warn(colors);
            scope.SimpleAction( scope.textMode==0 ? 'foreColor' : 'backColor' ,colors.colors)}
        }

        // watch the font size selector
        scope.$watch('size', function () {
          document.execCommand('styleWithCSS', false, false);
          document.execCommand('fontSize', false, scope.size);

        var fontElements = $content[0].getElementsByTagName("font");
        for (var i = 0, len = fontElements.length; i < len; ++i) {
          if (fontElements[i].size.length > 0)
          {
            console.log("font setting size is ", fontElements[i].size);
            fontElements[i].removeAttribute("size");
            fontElements[i].style.fontSize = scope.size + "px";  
          }
        }

          // custom event for two-way binding
          scope.$broadcast('meditor-change');
        });

        // watch the font family selector
        scope.$watch('family', function () {
          // dynamically load the family from google fonts
          if (window.WebFont) {
            WebFont.load({
              google: {
              families: [ scope.family ]
              }
            });
          }

          document.execCommand('styleWithCSS', false, true);
        document.execCommand('fontName', false, scope.family);
          // custom event for two-way binding
          scope.$broadcast('meditor-change');
        });

        // load google webfont library
        // to be able to dynamically load fonts
        (function () {
          var wf = document.createElement('script');
          wf.src = ('https:' === document.location.protocol ? 'https' : 'http') +
            '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
          wf.type = 'text/javascript';
          wf.async = 'true';
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(wf, s);
        })();

        // move the toolbar to the body, we can use overflow: hidden on containers

        ($playground.parent())[0].insertBefore($toolbar[0], $playground[0]);

        element.on('$destroy', function() {
          $toolbar.remove();
        });

      }
    };

  }])
  .directive('meditorContenteditable', ['$timeout', function ($timeout) {
    'use strict';

    return {
      require: '?ngModel',
      link: function (scope, elm, attrs, ctrl) {

        // don't throw an error without ng-model
        if (typeof scope.ngModel !== 'undefined') {

          var change = function () {
            $timeout(function () {
              ctrl.$setViewValue(elm.html());
            });
          };

          // custom event to change the ngModel after using
          // actions from the editor
          scope.$on('meditor-change', change);

          elm.on('blur keyup', change);

          ctrl.$render = function () {
            elm.html(ctrl.$viewValue);
          };

          ctrl.$setViewValue(scope.ngModel);
          elm.html(ctrl.$viewValue);

          scope.$watch('ngModel', function (ngModel) {
            // change the html only if it's different from the model
            // eg. on outside changes
            // so we don't lose the selection when editing with the
            // editor toolbar
            if (elm.html() !== ngModel) {
              elm.html(ngModel);
            }
          });

        }

      }
    };
  }]);